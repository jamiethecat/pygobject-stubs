import typing

from gi.repository import EDataServer
from gi.repository import Gio
from gi.repository import GLib
from gi.repository import GObject
from gi.repository import ICalGLib
from typing_extensions import Self

T = typing.TypeVar("T")

BACKEND_PROPERTY_ALARM_EMAIL_ADDRESS: str = "alarm-email-address"
BACKEND_PROPERTY_CAL_EMAIL_ADDRESS: str = "cal-email-address"
BACKEND_PROPERTY_DEFAULT_OBJECT: str = "default-object"
BACKEND_PROPERTY_REVISION: str = "revision"
EVOLUTION_ALARM_UID_PROPERTY: str = "X-EVOLUTION-ALARM-UID"
EVOLUTION_ENDDATE_PARAMETER: str = "X-EVOLUTION-ENDDATE"
LIBICAL_GLIB_UNSTABLE_API: int = 1
STATIC_CAPABILITY_ALARM_DESCRIPTION: str = "alarm-description"
STATIC_CAPABILITY_ALL_DAY_EVENT_AS_TIME: str = "all-day-event-as-time"
STATIC_CAPABILITY_BULK_ADDS: str = "bulk-adds"
STATIC_CAPABILITY_BULK_MODIFIES: str = "bulk-modifies"
STATIC_CAPABILITY_BULK_REMOVES: str = "bulk-removes"
STATIC_CAPABILITY_COMPONENT_COLOR: str = "component-color"
STATIC_CAPABILITY_CREATE_MESSAGES: str = "create-messages"
STATIC_CAPABILITY_DELEGATE_SUPPORTED: str = "delegate-support"
STATIC_CAPABILITY_DELEGATE_TO_MANY: str = "delegate-to-many"
STATIC_CAPABILITY_HAS_UNACCEPTED_MEETING: str = "has-unaccepted-meeting"
STATIC_CAPABILITY_ITIP_SUPPRESS_ON_REMOVE_SUPPORTED: str = (
    "itip-suppress-on-remove-supported"
)
STATIC_CAPABILITY_NO_ALARM_AFTER_START: str = "no-alarm-after-start"
STATIC_CAPABILITY_NO_ALARM_REPEAT: str = "no-alarm-repeat"
STATIC_CAPABILITY_NO_AUDIO_ALARMS: str = "no-audio-alarms"
STATIC_CAPABILITY_NO_CONV_TO_ASSIGN_TASK: str = "no-conv-to-assign-task"
STATIC_CAPABILITY_NO_CONV_TO_RECUR: str = "no-conv-to-recur"
STATIC_CAPABILITY_NO_DISPLAY_ALARMS: str = "no-display-alarms"
STATIC_CAPABILITY_NO_EMAIL_ALARMS: str = "no-email-alarms"
STATIC_CAPABILITY_NO_GEN_OPTIONS: str = "no-general-options"
STATIC_CAPABILITY_NO_MEMO_START_DATE: str = "no-memo-start-date"
STATIC_CAPABILITY_NO_ORGANIZER: str = "no-organizer"
STATIC_CAPABILITY_NO_PROCEDURE_ALARMS: str = "no-procedure-alarms"
STATIC_CAPABILITY_NO_TASK_ASSIGNMENT: str = "no-task-assignment"
STATIC_CAPABILITY_NO_THISANDFUTURE: str = "no-thisandfuture"
STATIC_CAPABILITY_NO_THISANDPRIOR: str = "no-thisandprior"
STATIC_CAPABILITY_NO_TRANSPARENCY: str = "no-transparency"
STATIC_CAPABILITY_ONE_ALARM_ONLY: str = "one-alarm-only"
STATIC_CAPABILITY_ORGANIZER_MUST_ACCEPT: str = "organizer-must-accept"
STATIC_CAPABILITY_ORGANIZER_MUST_ATTEND: str = "organizer-must-attend"
STATIC_CAPABILITY_ORGANIZER_NOT_EMAIL_ADDRESS: str = "organizer-not-email-address"
STATIC_CAPABILITY_RECURRENCES_NO_MASTER: str = "recurrences-no-master-object"
STATIC_CAPABILITY_REFRESH_SUPPORTED: str = "refresh-supported"
STATIC_CAPABILITY_REMOVE_ALARMS: str = "remove-alarms"
STATIC_CAPABILITY_REMOVE_ONLY_THIS: str = "remove-only-this"
STATIC_CAPABILITY_REQ_SEND_OPTIONS: str = "require-send-options"
STATIC_CAPABILITY_RETRACT_SUPPORTED: str = "retract-supported"
STATIC_CAPABILITY_SAVE_SCHEDULES: str = "save-schedules"
STATIC_CAPABILITY_SIMPLE_MEMO: str = "simple-memo"
STATIC_CAPABILITY_SIMPLE_MEMO_WITH_SUMMARY: str = "simple-memo-with-summary"
STATIC_CAPABILITY_TASK_CAN_RECUR: str = "task-can-recur"
STATIC_CAPABILITY_TASK_DATE_ONLY: str = "task-date-only"
STATIC_CAPABILITY_TASK_ESTIMATED_DURATION: str = "task-estimated-duration"
STATIC_CAPABILITY_TASK_HANDLE_RECUR: str = "task-handle-recur"
STATIC_CAPABILITY_TASK_NO_ALARM: str = "task-no-alarm"

def isodate_from_time_t(t: int) -> str: ...
def match_tzid(tzid: str) -> typing.Optional[str]: ...
def recur_describe_recurrence(
    icalcomp: ICalGLib.Component, week_start_day: GLib.DateWeekday, flags: int
) -> typing.Optional[str]: ...
def recur_describe_recurrence_ex(
    icalcomp: ICalGLib.Component,
    week_start_day: GLib.DateWeekday,
    flags: int,
    datetime_fmt_func: typing.Optional[
        typing.Callable[[ICalGLib.Time, str, int], None]
    ] = None,
) -> typing.Optional[str]: ...
def recur_ensure_end_dates(
    comp: Component,
    refresh: bool,
    tz_cb: typing.Callable[..., typing.Optional[ICalGLib.Timezone]],
    cancellable: typing.Optional[Gio.Cancellable] = None,
    *tz_cb_data: typing.Any,
) -> bool: ...
def recur_generate_instances_sync(
    icalcomp: ICalGLib.Component,
    interval_start: ICalGLib.Time,
    interval_end: ICalGLib.Time,
    callback: typing.Optional[typing.Callable[..., bool]],
    get_tz_callback: typing.Optional[
        typing.Callable[..., typing.Optional[ICalGLib.Timezone]]
    ],
    default_timezone: ICalGLib.Timezone,
    cancellable: typing.Optional[Gio.Cancellable] = None,
    *get_tz_callback_user_data: typing.Any,
) -> bool: ...
def recur_get_localized_nth(nth: int) -> str: ...
def recur_obtain_enddate(
    ir: ICalGLib.Recurrence,
    prop: ICalGLib.Property,
    zone: ICalGLib.Timezone,
    convert_end_date: bool,
) -> int: ...
def system_timezone_get_location() -> typing.Optional[str]: ...
def time_add_day(time: int, days: int) -> int: ...
def time_add_day_with_zone(time: int, days: int, zone: ICalGLib.Timezone) -> int: ...
def time_add_month_with_zone(
    time: int, months: int, zone: ICalGLib.Timezone
) -> int: ...
def time_add_week(time: int, weeks: int) -> int: ...
def time_add_week_with_zone(time: int, weeks: int, zone: ICalGLib.Timezone) -> int: ...
def time_day_begin(t: int) -> int: ...
def time_day_begin_with_zone(time: int, zone: ICalGLib.Timezone) -> int: ...
def time_day_end(t: int) -> int: ...
def time_day_end_with_zone(time: int, zone: ICalGLib.Timezone) -> int: ...
def time_day_of_week(day: int, month: int, year: int) -> int: ...
def time_day_of_year(day: int, month: int, year: int) -> int: ...
def time_days_in_month(year: int, month: int) -> int: ...
def time_from_isodate(str: str) -> int: ...
def time_is_leap_year(year: int) -> bool: ...
def time_leap_years_up_to(year: int) -> int: ...
def time_month_begin_with_zone(time: int, zone: ICalGLib.Timezone) -> int: ...
def time_to_gdate_with_zone(
    date: GLib.Date, time: int, zone: typing.Optional[ICalGLib.Timezone] = None
) -> None: ...
def time_week_begin_with_zone(
    time: int, week_start_day: int, zone: ICalGLib.Timezone
) -> int: ...
def time_year_begin_with_zone(time: int, zone: ICalGLib.Timezone) -> int: ...
def util_add_timezones_from_component(
    vcal_comp: ICalGLib.Component, icalcomp: ICalGLib.Component
) -> None: ...
def util_clamp_vtimezone(
    from_: ICalGLib.Time, to: typing.Optional[ICalGLib.Time] = None
) -> ICalGLib.Component: ...
def util_clamp_vtimezone_by_component(
    component: ICalGLib.Component,
) -> ICalGLib.Component: ...
def util_component_dup_x_property(
    icalcomp: ICalGLib.Component, x_name: str
) -> typing.Optional[str]: ...
def util_component_find_property_for_locale(
    icalcomp: ICalGLib.Component,
    prop_kind: ICalGLib.PropertyKind,
    locale: typing.Optional[str] = None,
) -> typing.Optional[ICalGLib.Property]: ...
def util_component_find_property_for_locale_filtered(
    icalcomp: ICalGLib.Component,
    prop_kind: ICalGLib.PropertyKind,
    locale: typing.Optional[str] = None,
    func: typing.Optional[typing.Callable[..., bool]] = None,
    *user_data: typing.Any,
) -> typing.Optional[ICalGLib.Property]: ...
def util_component_find_x_property(
    icalcomp: ICalGLib.Component, x_name: str
) -> typing.Optional[ICalGLib.Property]: ...
def util_component_get_recurid_as_string(
    icalcomp: ICalGLib.Component,
) -> typing.Optional[str]: ...
def util_component_has_alarms(icalcomp: ICalGLib.Component) -> bool: ...
def util_component_has_attendee(icalcomp: ICalGLib.Component) -> bool: ...
def util_component_has_organizer(icalcomp: ICalGLib.Component) -> bool: ...
def util_component_has_property(
    icalcomp: ICalGLib.Component, prop_kind: ICalGLib.PropertyKind
) -> bool: ...
def util_component_has_rdates(icalcomp: ICalGLib.Component) -> bool: ...
def util_component_has_recurrences(icalcomp: ICalGLib.Component) -> bool: ...
def util_component_has_rrules(icalcomp: ICalGLib.Component) -> bool: ...
def util_component_has_x_property(
    icalcomp: ICalGLib.Component, x_name: str
) -> bool: ...
def util_component_is_instance(icalcomp: ICalGLib.Component) -> bool: ...
def util_component_remove_property_by_kind(
    icalcomp: ICalGLib.Component, kind: ICalGLib.PropertyKind, all: bool
) -> int: ...
def util_component_remove_x_property(
    icalcomp: ICalGLib.Component, x_name: str
) -> bool: ...
def util_component_set_x_property(
    icalcomp: ICalGLib.Component, x_name: str, value: typing.Optional[str] = None
) -> None: ...
def util_conflict_resolution_to_operation_flags(
    conflict_resolution: EDataServer.ConflictResolution,
) -> int: ...
def util_construct_instance(
    icalcomp: ICalGLib.Component, rid: ICalGLib.Time
) -> typing.Optional[ICalGLib.Component]: ...
def util_copy_timezone(zone: ICalGLib.Timezone) -> ICalGLib.Timezone: ...
def util_diff_categories(
    old_comp: typing.Optional[ICalGLib.Component] = None,
    new_comp: typing.Optional[ICalGLib.Component] = None,
) -> typing.Tuple[dict[str, int], dict[str, int]]: ...
def util_email_addresses_equal(
    email1: typing.Optional[str] = None, email2: typing.Optional[str] = None
) -> bool: ...
def util_foreach_category(
    comp: ICalGLib.Component,
    func: typing.Callable[..., typing.Tuple[bool, str]],
    *user_data: typing.Any,
) -> None: ...
def util_generate_alarms_for_comp(
    comp: Component,
    start: int,
    end: int,
    omit: ComponentAlarmAction,
    resolve_tzid: typing.Callable[..., typing.Optional[ICalGLib.Timezone]],
    default_timezone: ICalGLib.Timezone,
    *user_data: typing.Any,
) -> typing.Optional[ComponentAlarms]: ...
def util_generate_alarms_for_list(
    comps: list[Component],
    start: int,
    end: int,
    omit: ComponentAlarmAction,
    resolve_tzid: typing.Callable[..., typing.Optional[ICalGLib.Timezone]],
    default_timezone: ICalGLib.Timezone,
    *user_data: typing.Any,
) -> typing.Tuple[int, list[ComponentAlarms]]: ...
def util_generate_alarms_for_uid_sync(
    client: None,
    uid: str,
    start: int,
    end: int,
    omit: ComponentAlarmAction,
    resolve_tzid: typing.Callable[..., typing.Optional[ICalGLib.Timezone]],
    default_timezone: ICalGLib.Timezone,
    def_reminder_before_start_seconds: int,
    cancellable: typing.Optional[Gio.Cancellable] = None,
    *user_data: typing.Any,
) -> typing.Optional[ComponentAlarms]: ...
def util_get_attendee_email(
    attendee: typing.Optional[ComponentAttendee] = None,
) -> typing.Optional[str]: ...
def util_get_component_occur_times(
    comp: Component,
    tz_cb: typing.Callable[..., typing.Optional[ICalGLib.Timezone]],
    default_timezone: ICalGLib.Timezone,
    kind: ICalGLib.ComponentKind,
    *tz_cb_data: typing.Any,
) -> typing.Tuple[int, int]: ...
def util_get_default_name_and_address(
    registry: EDataServer.SourceRegistry,
) -> typing.Tuple[bool, str, str]: ...
def util_get_organizer_email(
    organizer: typing.Optional[ComponentOrganizer] = None,
) -> typing.Optional[str]: ...
def util_get_property_email(prop: ICalGLib.Property) -> typing.Optional[str]: ...
def util_get_system_timezone() -> typing.Optional[ICalGLib.Timezone]: ...
def util_get_system_timezone_location() -> typing.Optional[str]: ...
def util_has_alarms_in_range(
    comp: Component,
    start: int,
    end: int,
    omit: ComponentAlarmAction,
    resolve_tzid: typing.Callable[..., typing.Optional[ICalGLib.Timezone]],
    default_timezone: ICalGLib.Timezone,
    *user_data: typing.Any,
) -> bool: ...
def util_icaltime_to_tm(itt: ICalGLib.Time) -> None: ...
def util_icaltime_to_tm_with_zone(
    itt: ICalGLib.Time, from_zone: ICalGLib.Timezone, to_zone: ICalGLib.Timezone
) -> None: ...
def util_init_recur_task_sync(
    vtodo: ICalGLib.Component,
    cal_client: Client,
    cancellable: typing.Optional[Gio.Cancellable] = None,
) -> bool: ...
def util_inline_local_attachments_sync(
    component: ICalGLib.Component, cancellable: typing.Optional[Gio.Cancellable] = None
) -> bool: ...
def util_is_first_instance(
    comp: Component,
    rid: ICalGLib.Time,
    tz_cb: typing.Callable[..., typing.Optional[ICalGLib.Timezone]],
    *tz_cb_data: typing.Any,
) -> bool: ...
def util_mark_task_complete_sync(
    vtodo: ICalGLib.Component,
    completed_time: int,
    cal_client: Client,
    cancellable: typing.Optional[Gio.Cancellable] = None,
) -> bool: ...
def util_new_component(kind: ICalGLib.ComponentKind) -> ICalGLib.Component: ...
def util_new_top_level() -> ICalGLib.Component: ...
def util_normalize_rrule_until_value(
    icalcomp: ICalGLib.Component,
    ttuntil: ICalGLib.Time,
    tz_cb: typing.Callable[..., typing.Optional[ICalGLib.Timezone]],
    *tz_cb_data: typing.Any,
) -> None: ...
def util_operation_flags_to_conflict_resolution(
    flags: int,
) -> EDataServer.ConflictResolution: ...
def util_parse_ics_file(filename: str) -> typing.Optional[ICalGLib.Component]: ...
def util_parse_ics_string(string: str) -> typing.Optional[ICalGLib.Component]: ...
def util_priority_from_string(string: str) -> int: ...
def util_priority_to_string(priority: int) -> str: ...
def util_property_has_parameter(
    prop: ICalGLib.Property, param_kind: ICalGLib.ParameterKind
) -> bool: ...
def util_remove_instances(
    icalcomp: ICalGLib.Component, rid: ICalGLib.Time, mod: ObjModType
) -> None: ...
def util_remove_instances_ex(
    icalcomp: ICalGLib.Component,
    rid: ICalGLib.Time,
    mod: ObjModType,
    tz_cb: typing.Callable[..., typing.Optional[ICalGLib.Timezone]],
    *tz_cb_data: typing.Any,
) -> None: ...
def util_seconds_to_string(seconds: int) -> str: ...
def util_set_alarm_acknowledged(component: Component, auid: str, when: int) -> bool: ...
def util_split_at_instance(
    icalcomp: ICalGLib.Component,
    rid: ICalGLib.Time,
    master_dtstart: typing.Optional[ICalGLib.Time] = None,
) -> typing.Optional[ICalGLib.Component]: ...
def util_split_at_instance_ex(
    icalcomp: ICalGLib.Component,
    rid: ICalGLib.Time,
    master_dtstart: typing.Optional[ICalGLib.Time],
    tz_cb: typing.Callable[..., typing.Optional[ICalGLib.Timezone]],
    *tz_cb_data: typing.Any,
) -> typing.Optional[ICalGLib.Component]: ...
def util_strip_mailto(address: typing.Optional[str] = None) -> str: ...
def util_tm_to_icaltime(tm: None, is_date: bool) -> ICalGLib.Time: ...

class Client(EDataServer.Client, TimezoneCache, Gio.AsyncInitable, Gio.Initable):
    """
    :Constructors:

    ::

        Client(**properties)

    Object ECalClient

    Signals from ECalClient:
      free-busy-data (gpointer)

    Properties from ECalClient:
      default-timezone -> ICalTimezone: Default Timezone
        Timezone used to resolve DATE and floating DATE-TIME values
      source-type -> ECalClientSourceType: Source Type
        The iCalendar data type

    Signals from ETimezoneCache:
      timezone-added (ICalTimezone)

    Signals from EClient:
      opened (GError)
      backend-error (gchararray)
      backend-died ()
      backend-property-changed (gchararray, gchararray)

    Properties from EClient:
      capabilities -> gpointer: Capabilities
        The capabilities of this client
      main-context -> GMainContext: Main Context
        The main loop context on which to attach event sources
      online -> gboolean: Online
        Whether this client is online
      opened -> gboolean: Opened
        Whether this client is open and ready to use
      readonly -> gboolean: Read only
        Whether this client's backing data is readonly
      source -> ESource: Source
        The ESource for which this client was created

    Signals from GObject:
      notify (GParam)
    """
    class Props(EDataServer.Client.Props):
        default_timezone: ICalGLib.Timezone
        source_type: ClientSourceType
        capabilities: None
        main_context: GLib.MainContext
        online: bool
        opened: bool
        readonly: bool
        source: EDataServer.Source

    props: Props = ...
    parent: EDataServer.Client = ...
    priv: ClientPrivate = ...
    def __init__(
        self,
        default_timezone: ICalGLib.Timezone = ...,
        source_type: ClientSourceType = ...,
        online: bool = ...,
        source: EDataServer.Source = ...,
    ) -> None: ...
    def add_timezone(
        self,
        zone: ICalGLib.Timezone,
        cancellable: typing.Optional[Gio.Cancellable] = None,
        callback: typing.Optional[typing.Callable[..., None]] = None,
        *user_data: typing.Any,
    ) -> None: ...
    def add_timezone_finish(self, result: Gio.AsyncResult) -> bool: ...
    def add_timezone_sync(
        self,
        zone: ICalGLib.Timezone,
        cancellable: typing.Optional[Gio.Cancellable] = None,
    ) -> bool: ...
    def check_one_alarm_only(self) -> bool: ...
    def check_organizer_must_accept(self) -> bool: ...
    def check_organizer_must_attend(self) -> bool: ...
    def check_recurrences_no_master(self) -> bool: ...
    def check_save_schedules(self) -> bool: ...
    @staticmethod
    def check_timezones_sync(
        vcalendar: ICalGLib.Component,
        icalcomps: typing.Optional[list[ICalGLib.Component]] = None,
        tzlookup: typing.Optional[
            typing.Callable[..., typing.Optional[ICalGLib.Timezone]]
        ] = None,
        cancellable: typing.Optional[Gio.Cancellable] = None,
        *tzlookup_data: typing.Any,
    ) -> bool: ...
    @staticmethod
    def connect(
        source: EDataServer.Source,
        source_type: ClientSourceType,
        wait_for_connected_seconds: int,
        cancellable: typing.Optional[Gio.Cancellable] = None,
        callback: typing.Optional[typing.Callable[..., None]] = None,
        *user_data: typing.Any,
    ) -> None: ...
    @staticmethod
    def connect_finish(result: Gio.AsyncResult) -> EDataServer.Client: ...
    @staticmethod
    def connect_sync(
        source: EDataServer.Source,
        source_type: ClientSourceType,
        wait_for_connected_seconds: int,
        cancellable: typing.Optional[Gio.Cancellable] = None,
    ) -> typing.Optional[EDataServer.Client]: ...
    def create_object(
        self,
        icalcomp: ICalGLib.Component,
        opflags: OperationFlags,
        cancellable: typing.Optional[Gio.Cancellable] = None,
        callback: typing.Optional[typing.Callable[..., None]] = None,
        *user_data: typing.Any,
    ) -> None: ...
    def create_object_finish(
        self, result: Gio.AsyncResult
    ) -> typing.Tuple[bool, str]: ...
    def create_object_sync(
        self,
        icalcomp: ICalGLib.Component,
        opflags: OperationFlags,
        cancellable: typing.Optional[Gio.Cancellable] = None,
    ) -> typing.Tuple[bool, str]: ...
    def create_objects(
        self,
        icalcomps: list[ICalGLib.Component],
        opflags: OperationFlags,
        cancellable: typing.Optional[Gio.Cancellable] = None,
        callback: typing.Optional[typing.Callable[..., None]] = None,
        *user_data: typing.Any,
    ) -> None: ...
    def create_objects_finish(
        self, result: Gio.AsyncResult
    ) -> typing.Tuple[bool, list[str]]: ...
    def create_objects_sync(
        self,
        icalcomps: list[ICalGLib.Component],
        opflags: OperationFlags,
        cancellable: typing.Optional[Gio.Cancellable] = None,
    ) -> typing.Tuple[bool, list[str]]: ...
    def discard_alarm(
        self,
        uid: str,
        rid: typing.Optional[str],
        auid: str,
        opflags: OperationFlags,
        cancellable: typing.Optional[Gio.Cancellable] = None,
        callback: typing.Optional[typing.Callable[..., None]] = None,
        *user_data: typing.Any,
    ) -> None: ...
    def discard_alarm_finish(self, result: Gio.AsyncResult) -> bool: ...
    def discard_alarm_sync(
        self,
        uid: str,
        rid: typing.Optional[str],
        auid: str,
        opflags: OperationFlags,
        cancellable: typing.Optional[Gio.Cancellable] = None,
    ) -> bool: ...
    @staticmethod
    def error_create(
        code: ClientError, custom_msg: typing.Optional[str] = None
    ) -> GLib.Error: ...
    @staticmethod
    def error_quark() -> int: ...
    @staticmethod
    def error_to_string(code: ClientError) -> str: ...
    def generate_instances(
        self,
        start: int,
        end: int,
        cancellable: typing.Optional[Gio.Cancellable],
        cb: typing.Callable[..., bool],
        *cb_data: typing.Any,
    ) -> None: ...
    def generate_instances_for_object(
        self,
        icalcomp: ICalGLib.Component,
        start: int,
        end: int,
        cancellable: typing.Optional[Gio.Cancellable],
        cb: typing.Callable[..., bool],
        *cb_data: typing.Any,
    ) -> None: ...
    def generate_instances_for_object_sync(
        self,
        icalcomp: ICalGLib.Component,
        start: int,
        end: int,
        cancellable: typing.Optional[Gio.Cancellable],
        cb: typing.Callable[..., bool],
        *cb_data: typing.Any,
    ) -> None: ...
    def generate_instances_for_uid_sync(
        self,
        uid: str,
        start: int,
        end: int,
        cancellable: typing.Optional[Gio.Cancellable],
        cb: typing.Callable[..., bool],
        *cb_data: typing.Any,
    ) -> None: ...
    def generate_instances_sync(
        self,
        start: int,
        end: int,
        cancellable: typing.Optional[Gio.Cancellable],
        cb: typing.Callable[..., bool],
        *cb_data: typing.Any,
    ) -> None: ...
    def get_attachment_uris(
        self,
        uid: str,
        rid: typing.Optional[str] = None,
        cancellable: typing.Optional[Gio.Cancellable] = None,
        callback: typing.Optional[typing.Callable[..., None]] = None,
        *user_data: typing.Any,
    ) -> None: ...
    def get_attachment_uris_finish(
        self, result: Gio.AsyncResult
    ) -> typing.Tuple[bool, list[str]]: ...
    def get_attachment_uris_sync(
        self,
        uid: str,
        rid: typing.Optional[str] = None,
        cancellable: typing.Optional[Gio.Cancellable] = None,
    ) -> typing.Tuple[bool, list[str]]: ...
    def get_component_as_string(
        self, icalcomp: ICalGLib.Component
    ) -> typing.Optional[str]: ...
    def get_default_object(
        self,
        cancellable: typing.Optional[Gio.Cancellable] = None,
        callback: typing.Optional[typing.Callable[..., None]] = None,
        *user_data: typing.Any,
    ) -> None: ...
    def get_default_object_finish(
        self, result: Gio.AsyncResult
    ) -> typing.Tuple[bool, ICalGLib.Component]: ...
    def get_default_object_sync(
        self, cancellable: typing.Optional[Gio.Cancellable] = None
    ) -> typing.Tuple[bool, ICalGLib.Component]: ...
    def get_default_timezone(self) -> ICalGLib.Timezone: ...
    def get_free_busy(
        self,
        start: int,
        end: int,
        users: list[str],
        cancellable: typing.Optional[Gio.Cancellable] = None,
        callback: typing.Optional[typing.Callable[..., None]] = None,
        *user_data: typing.Any,
    ) -> None: ...
    def get_free_busy_finish(
        self, result: Gio.AsyncResult
    ) -> typing.Tuple[bool, list[Component]]: ...
    def get_free_busy_sync(
        self,
        start: int,
        end: int,
        users: list[str],
        cancellable: typing.Optional[Gio.Cancellable] = None,
    ) -> typing.Tuple[bool, list[Component]]: ...
    def get_local_attachment_store(self) -> str: ...
    def get_object(
        self,
        uid: str,
        rid: typing.Optional[str] = None,
        cancellable: typing.Optional[Gio.Cancellable] = None,
        callback: typing.Optional[typing.Callable[..., None]] = None,
        *user_data: typing.Any,
    ) -> None: ...
    def get_object_finish(
        self, result: Gio.AsyncResult
    ) -> typing.Tuple[bool, ICalGLib.Component]: ...
    def get_object_list(
        self,
        sexp: str,
        cancellable: typing.Optional[Gio.Cancellable] = None,
        callback: typing.Optional[typing.Callable[..., None]] = None,
        *user_data: typing.Any,
    ) -> None: ...
    def get_object_list_as_comps(
        self,
        sexp: str,
        cancellable: typing.Optional[Gio.Cancellable] = None,
        callback: typing.Optional[typing.Callable[..., None]] = None,
        *user_data: typing.Any,
    ) -> None: ...
    def get_object_list_as_comps_finish(
        self, result: Gio.AsyncResult
    ) -> typing.Tuple[bool, list[Component]]: ...
    def get_object_list_as_comps_sync(
        self, sexp: str, cancellable: typing.Optional[Gio.Cancellable] = None
    ) -> typing.Tuple[bool, list[Component]]: ...
    def get_object_list_finish(
        self, result: Gio.AsyncResult
    ) -> typing.Tuple[bool, list[ICalGLib.Component]]: ...
    def get_object_list_sync(
        self, sexp: str, cancellable: typing.Optional[Gio.Cancellable] = None
    ) -> typing.Tuple[bool, list[ICalGLib.Component]]: ...
    def get_object_sync(
        self,
        uid: str,
        rid: typing.Optional[str] = None,
        cancellable: typing.Optional[Gio.Cancellable] = None,
    ) -> typing.Tuple[bool, ICalGLib.Component]: ...
    def get_objects_for_uid(
        self,
        uid: str,
        cancellable: typing.Optional[Gio.Cancellable] = None,
        callback: typing.Optional[typing.Callable[..., None]] = None,
        *user_data: typing.Any,
    ) -> None: ...
    def get_objects_for_uid_finish(
        self, result: Gio.AsyncResult
    ) -> typing.Tuple[bool, list[Component]]: ...
    def get_objects_for_uid_sync(
        self, uid: str, cancellable: typing.Optional[Gio.Cancellable] = None
    ) -> typing.Tuple[bool, list[Component]]: ...
    def get_source_type(self) -> ClientSourceType: ...
    def get_timezone(
        self,
        tzid: str,
        cancellable: typing.Optional[Gio.Cancellable] = None,
        callback: typing.Optional[typing.Callable[..., None]] = None,
        *user_data: typing.Any,
    ) -> None: ...
    def get_timezone_finish(
        self, result: Gio.AsyncResult
    ) -> typing.Tuple[bool, ICalGLib.Timezone]: ...
    def get_timezone_sync(
        self, tzid: str, cancellable: typing.Optional[Gio.Cancellable] = None
    ) -> typing.Tuple[bool, ICalGLib.Timezone]: ...
    def get_view(
        self,
        sexp: str,
        cancellable: typing.Optional[Gio.Cancellable] = None,
        callback: typing.Optional[typing.Callable[..., None]] = None,
        *user_data: typing.Any,
    ) -> None: ...
    def get_view_finish(
        self, result: Gio.AsyncResult
    ) -> typing.Tuple[bool, ClientView]: ...
    def get_view_sync(
        self, sexp: str, cancellable: typing.Optional[Gio.Cancellable] = None
    ) -> typing.Tuple[bool, ClientView]: ...
    def modify_object(
        self,
        icalcomp: ICalGLib.Component,
        mod: ObjModType,
        opflags: OperationFlags,
        cancellable: typing.Optional[Gio.Cancellable] = None,
        callback: typing.Optional[typing.Callable[..., None]] = None,
        *user_data: typing.Any,
    ) -> None: ...
    def modify_object_finish(self, result: Gio.AsyncResult) -> bool: ...
    def modify_object_sync(
        self,
        icalcomp: ICalGLib.Component,
        mod: ObjModType,
        opflags: OperationFlags,
        cancellable: typing.Optional[Gio.Cancellable] = None,
    ) -> bool: ...
    def modify_objects(
        self,
        icalcomps: list[ICalGLib.Component],
        mod: ObjModType,
        opflags: OperationFlags,
        cancellable: typing.Optional[Gio.Cancellable] = None,
        callback: typing.Optional[typing.Callable[..., None]] = None,
        *user_data: typing.Any,
    ) -> None: ...
    def modify_objects_finish(self, result: Gio.AsyncResult) -> bool: ...
    def modify_objects_sync(
        self,
        icalcomps: list[ICalGLib.Component],
        mod: ObjModType,
        opflags: OperationFlags,
        cancellable: typing.Optional[Gio.Cancellable] = None,
    ) -> bool: ...
    def receive_objects(
        self,
        icalcomp: ICalGLib.Component,
        opflags: OperationFlags,
        cancellable: typing.Optional[Gio.Cancellable] = None,
        callback: typing.Optional[typing.Callable[..., None]] = None,
        *user_data: typing.Any,
    ) -> None: ...
    def receive_objects_finish(self, result: Gio.AsyncResult) -> bool: ...
    def receive_objects_sync(
        self,
        icalcomp: ICalGLib.Component,
        opflags: OperationFlags,
        cancellable: typing.Optional[Gio.Cancellable] = None,
    ) -> bool: ...
    def remove_object(
        self,
        uid: str,
        rid: typing.Optional[str],
        mod: ObjModType,
        opflags: OperationFlags,
        cancellable: typing.Optional[Gio.Cancellable] = None,
        callback: typing.Optional[typing.Callable[..., None]] = None,
        *user_data: typing.Any,
    ) -> None: ...
    def remove_object_finish(self, result: Gio.AsyncResult) -> bool: ...
    def remove_object_sync(
        self,
        uid: str,
        rid: typing.Optional[str],
        mod: ObjModType,
        opflags: OperationFlags,
        cancellable: typing.Optional[Gio.Cancellable] = None,
    ) -> bool: ...
    def remove_objects(
        self,
        ids: list[ComponentId],
        mod: ObjModType,
        opflags: OperationFlags,
        cancellable: typing.Optional[Gio.Cancellable] = None,
        callback: typing.Optional[typing.Callable[..., None]] = None,
        *user_data: typing.Any,
    ) -> None: ...
    def remove_objects_finish(self, result: Gio.AsyncResult) -> bool: ...
    def remove_objects_sync(
        self,
        ids: list[ComponentId],
        mod: ObjModType,
        opflags: OperationFlags,
        cancellable: typing.Optional[Gio.Cancellable] = None,
    ) -> bool: ...
    def send_objects(
        self,
        icalcomp: ICalGLib.Component,
        opflags: OperationFlags,
        cancellable: typing.Optional[Gio.Cancellable] = None,
        callback: typing.Optional[typing.Callable[..., None]] = None,
        *user_data: typing.Any,
    ) -> None: ...
    def send_objects_finish(
        self, result: Gio.AsyncResult
    ) -> typing.Tuple[bool, list[str], ICalGLib.Component]: ...
    def send_objects_sync(
        self,
        icalcomp: ICalGLib.Component,
        opflags: OperationFlags,
        cancellable: typing.Optional[Gio.Cancellable] = None,
    ) -> typing.Tuple[bool, list[str], ICalGLib.Component]: ...
    def set_default_timezone(self, zone: ICalGLib.Timezone) -> None: ...
    @staticmethod
    def tzlookup_cb(
        tzid: str,
        ecalclient: Client,
        cancellable: typing.Optional[Gio.Cancellable] = None,
    ) -> typing.Optional[ICalGLib.Timezone]: ...
    @staticmethod
    def tzlookup_icalcomp_cb(
        tzid: str,
        lookup_data: ClientTzlookupICalCompData,
        cancellable: typing.Optional[Gio.Cancellable] = None,
    ) -> typing.Optional[ICalGLib.Timezone]: ...

class ClientClass(GObject.GPointer):
    """
    :Constructors:

    ::

        ClientClass()
    """

    parent: EDataServer.ClientClass = ...
    free_busy_data: None = ...

class ClientPrivate(GObject.GPointer): ...

class ClientTzlookupICalCompData(GObject.GBoxed):
    """
    :Constructors:

    ::

        new(icomp:ICalGLib.Component) -> ECal.ClientTzlookupICalCompData
    """
    def copy(self) -> typing.Optional[ClientTzlookupICalCompData]: ...
    def free(self) -> None: ...
    def get_icalcomponent(self) -> ICalGLib.Component: ...
    @classmethod
    def new(cls, icomp: ICalGLib.Component) -> ClientTzlookupICalCompData: ...

class ClientView(GObject.Object, Gio.Initable):
    """
    :Constructors:

    ::

        ClientView(**properties)

    Object ECalClientView

    Signals from ECalClientView:
      objects-added (gpointer)
      objects-modified (gpointer)
      objects-removed (gpointer)
      progress (guint, gchararray)
      complete (GError)

    Properties from ECalClientView:
      client -> ECalClient: Client
        The ECalClient for the view
      connection -> GDBusConnection: Connection
        The GDBusConnection used to create the D-Bus proxy
      object-path -> gchararray: Object Path
        The object path used to create the D-Bus proxy

    Signals from GObject:
      notify (GParam)
    """
    class Props(GObject.Object.Props):
        client: Client
        connection: Gio.DBusConnection
        object_path: str

    props: Props = ...
    object: GObject.Object = ...
    priv: ClientViewPrivate = ...
    def __init__(
        self,
        client: Client = ...,
        connection: Gio.DBusConnection = ...,
        object_path: str = ...,
    ) -> None: ...
    def do_complete(self, error: GLib.Error) -> None: ...
    def do_progress(self, percent: int, message: str) -> None: ...
    def get_connection(self) -> Gio.DBusConnection: ...
    def get_object_path(self) -> str: ...
    def is_running(self) -> bool: ...
    def ref_client(self) -> Client: ...
    def set_fields_of_interest(
        self, fields_of_interest: typing.Optional[list[str]] = None
    ) -> None: ...
    def set_flags(self, flags: ClientViewFlags) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

class ClientViewClass(GObject.GPointer):
    """
    :Constructors:

    ::

        ClientViewClass()
    """

    parent_class: GObject.ObjectClass = ...
    objects_added: None = ...
    objects_modified: None = ...
    objects_removed: None = ...
    progress: typing.Callable[[ClientView, int, str], None] = ...
    complete: typing.Callable[[ClientView, GLib.Error], None] = ...

class ClientViewPrivate(GObject.GPointer): ...

class Component(GObject.Object):
    """
    :Constructors:

    ::

        Component(**properties)
        new() -> ECal.Component
        new_from_icalcomponent(icalcomp:ICalGLib.Component) -> ECal.Component or None
        new_from_string(calobj:str) -> ECal.Component or None
        new_vtype(vtype:ECal.ComponentVType) -> ECal.Component

    Object ECalComponent

    Signals from GObject:
      notify (GParam)
    """

    parent: GObject.Object = ...
    priv: ComponentPrivate = ...
    def abort_sequence(self) -> None: ...
    def add_alarm(self, alarm: ComponentAlarm) -> None: ...
    def clone(self) -> Component: ...
    def commit_sequence(self) -> None: ...
    def dup_comment_for_locale(
        self, locale: typing.Optional[str] = None
    ) -> typing.Optional[ComponentText]: ...
    def dup_description_for_locale(
        self, locale: typing.Optional[str] = None
    ) -> typing.Optional[ComponentText]: ...
    def dup_summaries(self) -> typing.Optional[list[ComponentText]]: ...
    def dup_summary_for_locale(
        self, locale: typing.Optional[str] = None
    ) -> typing.Optional[ComponentText]: ...
    def get_alarm(self, auid: str) -> typing.Optional[ComponentAlarm]: ...
    def get_alarm_uids(self) -> typing.Optional[list[str]]: ...
    def get_all_alarms(self) -> typing.Optional[list[ComponentAlarm]]: ...
    def get_as_string(self) -> str: ...
    def get_attachments(self) -> typing.Optional[list[ICalGLib.Attach]]: ...
    def get_attendees(self) -> typing.Optional[list[ComponentAttendee]]: ...
    def get_categories(self) -> typing.Optional[str]: ...
    def get_categories_list(self) -> typing.Optional[list[str]]: ...
    def get_classification(self) -> ComponentClassification: ...
    def get_comments(self) -> typing.Optional[list[ComponentText]]: ...
    def get_completed(self) -> typing.Optional[ICalGLib.Time]: ...
    def get_contacts(self) -> list[ComponentText]: ...
    def get_created(self) -> typing.Optional[ICalGLib.Time]: ...
    def get_descriptions(self) -> typing.Optional[list[ComponentText]]: ...
    def get_dtend(self) -> typing.Optional[ComponentDateTime]: ...
    def get_dtstamp(self) -> typing.Optional[ICalGLib.Time]: ...
    def get_dtstart(self) -> typing.Optional[ComponentDateTime]: ...
    def get_due(self) -> typing.Optional[ComponentDateTime]: ...
    def get_exdates(self) -> typing.Optional[list[ComponentDateTime]]: ...
    def get_exrule_properties(self) -> typing.Optional[list[ICalGLib.Property]]: ...
    def get_exrules(self) -> typing.Optional[list[ICalGLib.Recurrence]]: ...
    def get_geo(self) -> typing.Optional[ICalGLib.Geo]: ...
    def get_icalcomponent(self) -> typing.Optional[ICalGLib.Component]: ...
    def get_id(self) -> ComponentId: ...
    def get_last_modified(self) -> typing.Optional[ICalGLib.Time]: ...
    def get_location(self) -> typing.Optional[str]: ...
    def get_organizer(self) -> typing.Optional[ComponentOrganizer]: ...
    def get_percent_complete(self) -> int: ...
    def get_priority(self) -> int: ...
    def get_rdates(self) -> typing.Optional[list[ComponentPeriod]]: ...
    def get_recurid(self) -> typing.Optional[ComponentRange]: ...
    def get_recurid_as_string(self) -> str: ...
    def get_rrule_properties(self) -> typing.Optional[list[ICalGLib.Property]]: ...
    def get_rrules(self) -> typing.Optional[list[ICalGLib.Recurrence]]: ...
    def get_sequence(self) -> int: ...
    def get_status(self) -> ICalGLib.PropertyStatus: ...
    def get_summary(self) -> typing.Optional[ComponentText]: ...
    def get_transparency(self) -> ComponentTransparency: ...
    def get_uid(self) -> str: ...
    def get_url(self) -> typing.Optional[str]: ...
    def get_vtype(self) -> ComponentVType: ...
    def has_alarms(self) -> bool: ...
    def has_attachments(self) -> bool: ...
    def has_attendees(self) -> bool: ...
    def has_exceptions(self) -> bool: ...
    def has_exdates(self) -> bool: ...
    def has_exrules(self) -> bool: ...
    def has_organizer(self) -> bool: ...
    def has_rdates(self) -> bool: ...
    def has_recurrences(self) -> bool: ...
    def has_rrules(self) -> bool: ...
    def has_simple_recurrence(self) -> bool: ...
    def is_instance(self) -> bool: ...
    @classmethod
    def new(cls) -> Component: ...
    @classmethod
    def new_from_icalcomponent(
        cls, icalcomp: ICalGLib.Component
    ) -> typing.Optional[Component]: ...
    @classmethod
    def new_from_string(cls, calobj: str) -> typing.Optional[Component]: ...
    @classmethod
    def new_vtype(cls, vtype: ComponentVType) -> Component: ...
    def remove_alarm(self, auid: str) -> None: ...
    def remove_all_alarms(self) -> None: ...
    def set_attachments(
        self, attachments: typing.Optional[list[ICalGLib.Attach]] = None
    ) -> None: ...
    def set_attendees(
        self, attendee_list: typing.Optional[list[ComponentAttendee]] = None
    ) -> None: ...
    def set_categories(self, categories: str) -> None: ...
    def set_categories_list(self, categ_list: list[str]) -> None: ...
    def set_classification(self, classif: ComponentClassification) -> None: ...
    def set_comments(self, text_list: list[ComponentText]) -> None: ...
    def set_completed(self, tt: typing.Optional[ICalGLib.Time] = None) -> None: ...
    def set_contacts(self, text_list: list[ComponentText]) -> None: ...
    def set_created(self, tt: typing.Optional[ICalGLib.Time] = None) -> None: ...
    def set_descriptions(self, text_list: list[ComponentText]) -> None: ...
    def set_dtend(self, dt: typing.Optional[ComponentDateTime] = None) -> None: ...
    def set_dtstamp(self, tt: ICalGLib.Time) -> None: ...
    def set_dtstart(self, dt: typing.Optional[ComponentDateTime] = None) -> None: ...
    def set_due(self, dt: typing.Optional[ComponentDateTime] = None) -> None: ...
    def set_exdates(
        self, exdate_list: typing.Optional[list[ComponentDateTime]] = None
    ) -> None: ...
    def set_exrules(
        self, recur_list: typing.Optional[list[ICalGLib.Recurrence]] = None
    ) -> None: ...
    def set_geo(self, geo: typing.Optional[ICalGLib.Geo] = None) -> None: ...
    def set_icalcomponent(
        self, icalcomp: typing.Optional[ICalGLib.Component] = None
    ) -> bool: ...
    def set_last_modified(self, tt: typing.Optional[ICalGLib.Time] = None) -> None: ...
    def set_location(self, location: typing.Optional[str] = None) -> None: ...
    def set_new_vtype(self, type: ComponentVType) -> None: ...
    def set_organizer(
        self, organizer: typing.Optional[ComponentOrganizer] = None
    ) -> None: ...
    def set_percent_complete(self, percent: int) -> None: ...
    def set_priority(self, priority: int) -> None: ...
    def set_rdates(
        self, rdate_list: typing.Optional[list[ComponentPeriod]] = None
    ) -> None: ...
    def set_recurid(self, recur_id: typing.Optional[ComponentRange] = None) -> None: ...
    def set_rrules(
        self, recur_list: typing.Optional[list[ICalGLib.Recurrence]] = None
    ) -> None: ...
    def set_sequence(self, sequence: int) -> None: ...
    def set_status(self, status: ICalGLib.PropertyStatus) -> None: ...
    def set_summaries(self, text_list: list[ComponentText]) -> None: ...
    def set_summary(self, summary: ComponentText) -> None: ...
    def set_transparency(self, transp: ComponentTransparency) -> None: ...
    def set_uid(self, uid: str) -> None: ...
    def set_url(self, url: typing.Optional[str] = None) -> None: ...
    def strip_errors(self) -> None: ...

class ComponentAlarm(GObject.GBoxed):
    """
    :Constructors:

    ::

        new() -> ECal.ComponentAlarm
        new_from_component(component:ICalGLib.Component) -> ECal.ComponentAlarm or None
    """
    def copy(self) -> ComponentAlarm: ...
    def fill_component(self, component: ICalGLib.Component) -> None: ...
    def get_acknowledged(self) -> typing.Optional[ICalGLib.Time]: ...
    def get_action(self) -> ComponentAlarmAction: ...
    def get_as_component(self) -> ICalGLib.Component: ...
    def get_attachments(self) -> typing.Optional[list[ICalGLib.Attach]]: ...
    def get_attendees(self) -> typing.Optional[list[ComponentAttendee]]: ...
    def get_description(self) -> typing.Optional[ComponentText]: ...
    def get_property_bag(self) -> ComponentPropertyBag: ...
    def get_repeat(self) -> typing.Optional[ComponentAlarmRepeat]: ...
    def get_summary(self) -> typing.Optional[ComponentText]: ...
    def get_trigger(self) -> typing.Optional[ComponentAlarmTrigger]: ...
    def get_uid(self) -> typing.Optional[str]: ...
    def has_attachments(self) -> bool: ...
    def has_attendees(self) -> bool: ...
    @classmethod
    def new(cls) -> ComponentAlarm: ...
    @classmethod
    def new_from_component(
        cls, component: ICalGLib.Component
    ) -> typing.Optional[ComponentAlarm]: ...
    def set_acknowledged(self, when: typing.Optional[ICalGLib.Time] = None) -> None: ...
    def set_action(self, action: ComponentAlarmAction) -> None: ...
    def set_attachments(
        self, attachments: typing.Optional[list[ICalGLib.Attach]] = None
    ) -> None: ...
    def set_attendees(
        self, attendees: typing.Optional[list[ComponentAttendee]] = None
    ) -> None: ...
    def set_description(
        self, description: typing.Optional[ComponentText] = None
    ) -> None: ...
    def set_from_component(self, component: ICalGLib.Component) -> None: ...
    def set_repeat(
        self, repeat: typing.Optional[ComponentAlarmRepeat] = None
    ) -> None: ...
    def set_summary(self, summary: typing.Optional[ComponentText] = None) -> None: ...
    def set_trigger(
        self, trigger: typing.Optional[ComponentAlarmTrigger] = None
    ) -> None: ...
    def set_uid(self, uid: typing.Optional[str] = None) -> None: ...
    def take_acknowledged(
        self, when: typing.Optional[ICalGLib.Time] = None
    ) -> None: ...

class ComponentAlarmInstance(GObject.GBoxed):
    """
    :Constructors:

    ::

        new(uid:str, instance_time:int, occur_start:int, occur_end:int) -> ECal.ComponentAlarmInstance
    """
    def copy(self) -> ComponentAlarmInstance: ...
    def get_component(self) -> None: ...
    def get_occur_end(self) -> int: ...
    def get_occur_start(self) -> int: ...
    def get_rid(self) -> typing.Optional[str]: ...
    def get_time(self) -> int: ...
    def get_uid(self) -> str: ...
    @classmethod
    def new(
        cls, uid: str, instance_time: int, occur_start: int, occur_end: int
    ) -> ComponentAlarmInstance: ...
    def set_component(self, component: None) -> None: ...
    def set_occur_end(self, occur_end: int) -> None: ...
    def set_occur_start(self, occur_start: int) -> None: ...
    def set_rid(self, rid: typing.Optional[str] = None) -> None: ...
    def set_time(self, instance_time: int) -> None: ...
    def set_uid(self, uid: str) -> None: ...

class ComponentAlarmRepeat(GObject.GBoxed):
    """
    :Constructors:

    ::

        new(repetitions:int, interval:ICalGLib.Duration) -> ECal.ComponentAlarmRepeat
        new_seconds(repetitions:int, interval_seconds:int) -> ECal.ComponentAlarmRepeat
    """
    def copy(self) -> ComponentAlarmRepeat: ...
    def get_interval(self) -> ICalGLib.Duration: ...
    def get_interval_seconds(self) -> int: ...
    def get_repetitions(self) -> int: ...
    @classmethod
    def new(
        cls, repetitions: int, interval: ICalGLib.Duration
    ) -> ComponentAlarmRepeat: ...
    @classmethod
    def new_seconds(
        cls, repetitions: int, interval_seconds: int
    ) -> ComponentAlarmRepeat: ...
    def set_interval(self, interval: ICalGLib.Duration) -> None: ...
    def set_interval_seconds(self, interval_seconds: int) -> None: ...
    def set_repetitions(self, repetitions: int) -> None: ...

class ComponentAlarmTrigger(GObject.GBoxed):
    """
    :Constructors:

    ::

        new_absolute(absolute_time:ICalGLib.Time) -> ECal.ComponentAlarmTrigger
        new_from_property(property:ICalGLib.Property) -> ECal.ComponentAlarmTrigger or None
        new_relative(kind:ECal.ComponentAlarmTriggerKind, duration:ICalGLib.Duration) -> ECal.ComponentAlarmTrigger
    """
    def copy(self) -> ComponentAlarmTrigger: ...
    def fill_property(self) -> ICalGLib.Property: ...
    def get_absolute_time(self) -> typing.Optional[ICalGLib.Time]: ...
    def get_as_property(self) -> ICalGLib.Property: ...
    def get_duration(self) -> typing.Optional[ICalGLib.Duration]: ...
    def get_kind(self) -> ComponentAlarmTriggerKind: ...
    def get_parameter_bag(self) -> ComponentParameterBag: ...
    @classmethod
    def new_absolute(cls, absolute_time: ICalGLib.Time) -> ComponentAlarmTrigger: ...
    @classmethod
    def new_from_property(
        cls, property: ICalGLib.Property
    ) -> typing.Optional[ComponentAlarmTrigger]: ...
    @classmethod
    def new_relative(
        cls, kind: ComponentAlarmTriggerKind, duration: ICalGLib.Duration
    ) -> ComponentAlarmTrigger: ...
    def set_absolute(self, absolute_time: ICalGLib.Time) -> None: ...
    def set_absolute_time(self, absolute_time: ICalGLib.Time) -> None: ...
    def set_duration(self, duration: ICalGLib.Duration) -> None: ...
    def set_from_property(self, property: ICalGLib.Property) -> None: ...
    def set_kind(self, kind: ComponentAlarmTriggerKind) -> None: ...
    def set_relative(
        self, kind: ComponentAlarmTriggerKind, duration: ICalGLib.Duration
    ) -> None: ...

class ComponentAlarms(GObject.GBoxed):
    """
    :Constructors:

    ::

        new(comp:ECal.Component=None) -> ECal.ComponentAlarms
    """
    def add_instance(self, instance: ComponentAlarmInstance) -> None: ...
    def copy(self) -> ComponentAlarms: ...
    def get_component(self) -> typing.Optional[Component]: ...
    def get_instances(self) -> typing.Optional[list[ComponentAlarmInstance]]: ...
    @classmethod
    def new(cls, comp: typing.Optional[Component] = None) -> ComponentAlarms: ...
    def remove_instance(self, instance: ComponentAlarmInstance) -> bool: ...
    def set_instances(
        self, instances: typing.Optional[list[ComponentAlarmInstance]] = None
    ) -> None: ...
    def take_instance(self, instance: ComponentAlarmInstance) -> None: ...
    def take_instances(
        self, instances: typing.Optional[list[ComponentAlarmInstance]] = None
    ) -> None: ...

class ComponentAttendee(GObject.GBoxed):
    """
    :Constructors:

    ::

        new() -> ECal.ComponentAttendee
        new_from_property(property:ICalGLib.Property) -> ECal.ComponentAttendee or None
        new_full(value:str=None, member:str=None, cutype:ICalGLib.ParameterCutype, role:ICalGLib.ParameterRole, partstat:ICalGLib.ParameterPartstat, rsvp:bool, delegatedfrom:str=None, delegatedto:str=None, sentby:str=None, cn:str=None, language:str=None) -> ECal.ComponentAttendee
    """
    def copy(self) -> ComponentAttendee: ...
    def fill_property(self) -> ICalGLib.Property: ...
    def get_as_property(self) -> ICalGLib.Property: ...
    def get_cn(self) -> typing.Optional[str]: ...
    def get_cutype(self) -> ICalGLib.ParameterCutype: ...
    def get_delegatedfrom(self) -> typing.Optional[str]: ...
    def get_delegatedto(self) -> typing.Optional[str]: ...
    def get_language(self) -> typing.Optional[str]: ...
    def get_member(self) -> typing.Optional[str]: ...
    def get_parameter_bag(self) -> ComponentParameterBag: ...
    def get_partstat(self) -> ICalGLib.ParameterPartstat: ...
    def get_role(self) -> ICalGLib.ParameterRole: ...
    def get_rsvp(self) -> bool: ...
    def get_sentby(self) -> typing.Optional[str]: ...
    def get_value(self) -> typing.Optional[str]: ...
    @classmethod
    def new(cls) -> ComponentAttendee: ...
    @classmethod
    def new_from_property(
        cls, property: ICalGLib.Property
    ) -> typing.Optional[ComponentAttendee]: ...
    @classmethod
    def new_full(
        cls,
        value: typing.Optional[str],
        member: typing.Optional[str],
        cutype: ICalGLib.ParameterCutype,
        role: ICalGLib.ParameterRole,
        partstat: ICalGLib.ParameterPartstat,
        rsvp: bool,
        delegatedfrom: typing.Optional[str] = None,
        delegatedto: typing.Optional[str] = None,
        sentby: typing.Optional[str] = None,
        cn: typing.Optional[str] = None,
        language: typing.Optional[str] = None,
    ) -> ComponentAttendee: ...
    def set_cn(self, cn: typing.Optional[str] = None) -> None: ...
    def set_cutype(self, cutype: ICalGLib.ParameterCutype) -> None: ...
    def set_delegatedfrom(self, delegatedfrom: typing.Optional[str] = None) -> None: ...
    def set_delegatedto(self, delegatedto: typing.Optional[str] = None) -> None: ...
    def set_from_property(self, property: ICalGLib.Property) -> None: ...
    def set_language(self, language: typing.Optional[str] = None) -> None: ...
    def set_member(self, member: typing.Optional[str] = None) -> None: ...
    def set_partstat(self, partstat: ICalGLib.ParameterPartstat) -> None: ...
    def set_role(self, role: ICalGLib.ParameterRole) -> None: ...
    def set_rsvp(self, rsvp: bool) -> None: ...
    def set_sentby(self, sentby: typing.Optional[str] = None) -> None: ...
    def set_value(self, value: typing.Optional[str] = None) -> None: ...

class ComponentClass(GObject.GPointer):
    """
    :Constructors:

    ::

        ComponentClass()
    """

    parent_class: GObject.ObjectClass = ...

class ComponentDateTime(GObject.GBoxed):
    """
    :Constructors:

    ::

        new(value:ICalGLib.Time, tzid:str=None) -> ECal.ComponentDateTime
        new_take(value:ICalGLib.Time, tzid:str=None) -> ECal.ComponentDateTime
    """
    def copy(self) -> ComponentDateTime: ...
    def get_tzid(self) -> typing.Optional[str]: ...
    def get_value(self) -> ICalGLib.Time: ...
    @classmethod
    def new(
        cls, value: ICalGLib.Time, tzid: typing.Optional[str] = None
    ) -> ComponentDateTime: ...
    @classmethod
    def new_take(
        cls, value: ICalGLib.Time, tzid: typing.Optional[str] = None
    ) -> ComponentDateTime: ...
    def set(self, value: ICalGLib.Time, tzid: typing.Optional[str] = None) -> None: ...
    def set_tzid(self, tzid: typing.Optional[str] = None) -> None: ...
    def set_value(self, value: ICalGLib.Time) -> None: ...
    def take_tzid(self, tzid: typing.Optional[str] = None) -> None: ...
    def take_value(self, value: ICalGLib.Time) -> None: ...

class ComponentId(GObject.GBoxed):
    """
    :Constructors:

    ::

        new(uid:str, rid:str=None) -> ECal.ComponentId
        new_take(uid:str, rid:str=None) -> ECal.ComponentId
    """
    def copy(self) -> ComponentId: ...
    def equal(self, id2: ComponentId) -> bool: ...
    def get_rid(self) -> typing.Optional[str]: ...
    def get_uid(self) -> str: ...
    def hash(self) -> int: ...
    @classmethod
    def new(cls, uid: str, rid: typing.Optional[str] = None) -> ComponentId: ...
    @classmethod
    def new_take(cls, uid: str, rid: typing.Optional[str] = None) -> ComponentId: ...
    def set_rid(self, rid: typing.Optional[str] = None) -> None: ...
    def set_uid(self, uid: str) -> None: ...

class ComponentOrganizer(GObject.GBoxed):
    """
    :Constructors:

    ::

        new() -> ECal.ComponentOrganizer
        new_from_property(property:ICalGLib.Property) -> ECal.ComponentOrganizer or None
        new_full(value:str=None, sentby:str=None, cn:str=None, language:str=None) -> ECal.ComponentOrganizer
    """
    def copy(self) -> ComponentOrganizer: ...
    def fill_property(self) -> ICalGLib.Property: ...
    def get_as_property(self) -> ICalGLib.Property: ...
    def get_cn(self) -> typing.Optional[str]: ...
    def get_language(self) -> typing.Optional[str]: ...
    def get_parameter_bag(self) -> ComponentParameterBag: ...
    def get_sentby(self) -> typing.Optional[str]: ...
    def get_value(self) -> typing.Optional[str]: ...
    @classmethod
    def new(cls) -> ComponentOrganizer: ...
    @classmethod
    def new_from_property(
        cls, property: ICalGLib.Property
    ) -> typing.Optional[ComponentOrganizer]: ...
    @classmethod
    def new_full(
        cls,
        value: typing.Optional[str] = None,
        sentby: typing.Optional[str] = None,
        cn: typing.Optional[str] = None,
        language: typing.Optional[str] = None,
    ) -> ComponentOrganizer: ...
    def set_cn(self, cn: typing.Optional[str] = None) -> None: ...
    def set_from_property(self, property: ICalGLib.Property) -> None: ...
    def set_language(self, language: typing.Optional[str] = None) -> None: ...
    def set_sentby(self, sentby: typing.Optional[str] = None) -> None: ...
    def set_value(self, value: typing.Optional[str] = None) -> None: ...

class ComponentParameterBag(GObject.GBoxed):
    """
    :Constructors:

    ::

        new() -> ECal.ComponentParameterBag
        new_from_property(property:ICalGLib.Property, func:ECal.ComponentParameterBagFilterFunc=None, user_data=None) -> ECal.ComponentParameterBag
    """
    def add(self, param: ICalGLib.Parameter) -> None: ...
    def assign(self, src_bag: ComponentParameterBag) -> None: ...
    def clear(self) -> None: ...
    def copy(self) -> ComponentParameterBag: ...
    def fill_property(self, property: ICalGLib.Property) -> None: ...
    def get(self, index: int) -> typing.Optional[ICalGLib.Parameter]: ...
    def get_count(self) -> int: ...
    def get_first_by_kind(self, kind: ICalGLib.ParameterKind) -> int: ...
    @classmethod
    def new(cls) -> ComponentParameterBag: ...
    @classmethod
    def new_from_property(
        cls,
        property: ICalGLib.Property,
        func: typing.Optional[typing.Callable[..., bool]] = None,
        *user_data: typing.Any,
    ) -> ComponentParameterBag: ...
    def remove(self, index: int) -> None: ...
    def remove_by_kind(self, kind: ICalGLib.ParameterKind, all: bool) -> int: ...
    def set_from_property(
        self,
        property: ICalGLib.Property,
        func: typing.Optional[typing.Callable[..., bool]] = None,
        *user_data: typing.Any,
    ) -> None: ...
    def take(self, param: ICalGLib.Parameter) -> None: ...

class ComponentPeriod(GObject.GBoxed):
    """
    :Constructors:

    ::

        new_datetime(start:ICalGLib.Time, end:ICalGLib.Time=None) -> ECal.ComponentPeriod
        new_duration(start:ICalGLib.Time, duration:ICalGLib.Duration) -> ECal.ComponentPeriod
    """
    def copy(self) -> ComponentPeriod: ...
    def get_duration(self) -> ICalGLib.Duration: ...
    def get_end(self) -> typing.Optional[ICalGLib.Time]: ...
    def get_kind(self) -> ComponentPeriodKind: ...
    def get_start(self) -> ICalGLib.Time: ...
    @classmethod
    def new_datetime(
        cls, start: ICalGLib.Time, end: typing.Optional[ICalGLib.Time] = None
    ) -> ComponentPeriod: ...
    @classmethod
    def new_duration(
        cls, start: ICalGLib.Time, duration: ICalGLib.Duration
    ) -> ComponentPeriod: ...
    def set_datetime_full(
        self, start: ICalGLib.Time, end: typing.Optional[ICalGLib.Time] = None
    ) -> None: ...
    def set_duration(self, duration: ICalGLib.Duration) -> None: ...
    def set_duration_full(
        self, start: ICalGLib.Time, duration: ICalGLib.Duration
    ) -> None: ...
    def set_end(self, end: typing.Optional[ICalGLib.Time] = None) -> None: ...
    def set_start(self, start: ICalGLib.Time) -> None: ...

class ComponentPrivate(GObject.GPointer): ...

class ComponentPropertyBag(GObject.GBoxed):
    """
    :Constructors:

    ::

        new() -> ECal.ComponentPropertyBag
        new_from_component(component:ICalGLib.Component, func:ECal.ComponentPropertyBagFilterFunc=None, user_data=None) -> ECal.ComponentPropertyBag
    """
    def add(self, prop: ICalGLib.Property) -> None: ...
    def assign(self, src_bag: ComponentPropertyBag) -> None: ...
    def clear(self) -> None: ...
    def copy(self) -> ComponentPropertyBag: ...
    def fill_component(self, component: ICalGLib.Component) -> None: ...
    def get(self, index: int) -> typing.Optional[ICalGLib.Property]: ...
    def get_count(self) -> int: ...
    def get_first_by_kind(self, kind: ICalGLib.PropertyKind) -> int: ...
    @classmethod
    def new(cls) -> ComponentPropertyBag: ...
    @classmethod
    def new_from_component(
        cls,
        component: ICalGLib.Component,
        func: typing.Optional[typing.Callable[..., bool]] = None,
        *user_data: typing.Any,
    ) -> ComponentPropertyBag: ...
    def remove(self, index: int) -> None: ...
    def remove_by_kind(self, kind: ICalGLib.PropertyKind, all: bool) -> int: ...
    def set_from_component(
        self,
        component: ICalGLib.Component,
        func: typing.Optional[typing.Callable[..., bool]] = None,
        *user_data: typing.Any,
    ) -> None: ...
    def take(self, prop: ICalGLib.Property) -> None: ...

class ComponentRange(GObject.GBoxed):
    """
    :Constructors:

    ::

        new(kind:ECal.ComponentRangeKind, datetime:ECal.ComponentDateTime) -> ECal.ComponentRange
    """
    def copy(self) -> ComponentRange: ...
    def get_datetime(self) -> ComponentDateTime: ...
    def get_kind(self) -> ComponentRangeKind: ...
    @classmethod
    def new(
        cls, kind: ComponentRangeKind, datetime: ComponentDateTime
    ) -> ComponentRange: ...
    def set_datetime(self, datetime: ComponentDateTime) -> None: ...
    def set_kind(self, kind: ComponentRangeKind) -> None: ...

class ComponentText(GObject.GBoxed):
    """
    :Constructors:

    ::

        new(value:str=None, altrep:str=None) -> ECal.ComponentText
        new_from_property(property:ICalGLib.Property) -> ECal.ComponentText
    """
    def copy(self) -> ComponentText: ...
    def fill_property(self, property: ICalGLib.Property) -> None: ...
    def get_altrep(self) -> str: ...
    def get_language(self) -> str: ...
    def get_value(self) -> str: ...
    @classmethod
    def new(
        cls, value: typing.Optional[str] = None, altrep: typing.Optional[str] = None
    ) -> ComponentText: ...
    @classmethod
    def new_from_property(cls, property: ICalGLib.Property) -> ComponentText: ...
    def set_altrep(self, altrep: typing.Optional[str] = None) -> None: ...
    def set_from_property(self, property: ICalGLib.Property) -> None: ...
    def set_language(self, language: typing.Optional[str] = None) -> None: ...
    def set_value(self, value: typing.Optional[str] = None) -> None: ...

class ReminderData(GObject.GBoxed):
    """
    :Constructors:

    ::

        new(source_uid:str, component:ECal.Component, instance:ECal.ComponentAlarmInstance) -> ECal.ReminderData
    """
    def copy(self) -> typing.Optional[ReminderData]: ...
    def free(self) -> None: ...
    def get_component(self) -> Component: ...
    def get_instance(self) -> ComponentAlarmInstance: ...
    def get_source_uid(self) -> str: ...
    @classmethod
    def new(
        cls, source_uid: str, component: Component, instance: ComponentAlarmInstance
    ) -> ReminderData: ...
    def set_component(self, component: Component) -> None: ...
    def set_instance(self, instance: ComponentAlarmInstance) -> None: ...
    def set_source_uid(self, source_uid: str) -> None: ...

class ReminderWatcher(GObject.Object):
    """
    :Constructors:

    ::

        ReminderWatcher(**properties)
        new(registry:EDataServer.SourceRegistry) -> ECal.ReminderWatcher

    Object EReminderWatcher

    Signals from EReminderWatcher:
      format-time (EReminderData, ICalTime, gpointer, gint)
      triggered (gpointer, gboolean)
      changed ()

    Properties from EReminderWatcher:
      registry -> ESourceRegistry: Registry
        Data source registry
      default-zone -> ICalTimezone: Default Zone
        The default time zone
      timers-enabled -> gboolean: Timers Enabled
        Whether can schedule timers

    Signals from GObject:
      notify (GParam)
    """
    class Props(GObject.Object.Props):
        default_zone: typing.Optional[ICalGLib.Timezone]
        registry: EDataServer.SourceRegistry
        timers_enabled: bool

    props: Props = ...
    parent: GObject.Object = ...
    priv: ReminderWatcherPrivate = ...
    def __init__(
        self,
        default_zone: typing.Optional[ICalGLib.Timezone] = ...,
        registry: EDataServer.SourceRegistry = ...,
        timers_enabled: bool = ...,
    ) -> None: ...
    def describe_data(self, rd: ReminderData, flags: int) -> str: ...
    def dismiss(
        self,
        rd: ReminderData,
        cancellable: typing.Optional[Gio.Cancellable] = None,
        callback: typing.Optional[typing.Callable[..., None]] = None,
        *user_data: typing.Any,
    ) -> None: ...
    def dismiss_all(
        self,
        cancellable: typing.Optional[Gio.Cancellable] = None,
        callback: typing.Optional[typing.Callable[..., None]] = None,
        *user_data: typing.Any,
    ) -> None: ...
    def dismiss_all_finish(self, result: Gio.AsyncResult) -> bool: ...
    def dismiss_all_sync(
        self, cancellable: typing.Optional[Gio.Cancellable] = None
    ) -> bool: ...
    def dismiss_finish(self, result: Gio.AsyncResult) -> bool: ...
    def dismiss_sync(
        self, rd: ReminderData, cancellable: typing.Optional[Gio.Cancellable] = None
    ) -> bool: ...
    def do_cal_client_connect(
        self,
        source: EDataServer.Source,
        source_type: ClientSourceType,
        wait_for_connected_seconds: int,
        cancellable: typing.Optional[Gio.Cancellable] = None,
        callback: typing.Optional[typing.Callable[..., None]] = None,
        *user_data: typing.Any,
    ) -> None: ...
    def do_changed(self) -> None: ...
    def do_format_time(
        self, rd: ReminderData, itt: ICalGLib.Time, inout_buffer: str, buffer_size: int
    ) -> None: ...
    def do_schedule_timer(self, at_time: int) -> None: ...
    def dup_default_zone(self) -> ICalGLib.Timezone: ...
    def dup_past(self) -> typing.Optional[list[ReminderData]]: ...
    def dup_snoozed(self) -> typing.Optional[list[ReminderData]]: ...
    def get_registry(self) -> EDataServer.SourceRegistry: ...
    def get_timers_enabled(self) -> bool: ...
    @classmethod
    def new(cls, registry: EDataServer.SourceRegistry) -> ReminderWatcher: ...
    def ref_opened_client(self, source_uid: str) -> typing.Optional[Client]: ...
    def set_default_zone(
        self, zone: typing.Optional[ICalGLib.Timezone] = None
    ) -> None: ...
    def set_timers_enabled(self, enabled: bool) -> None: ...
    def snooze(self, rd: ReminderData, until: int) -> None: ...
    def timer_elapsed(self) -> None: ...

class ReminderWatcherClass(GObject.GPointer):
    """
    :Constructors:

    ::

        ReminderWatcherClass()
    """

    parent_class: GObject.ObjectClass = ...
    schedule_timer: typing.Callable[[ReminderWatcher, int], None] = ...
    format_time: typing.Callable[
        [ReminderWatcher, ReminderData, ICalGLib.Time, str, int], None
    ] = ...
    triggered: None = ...
    changed: typing.Callable[[ReminderWatcher], None] = ...
    cal_client_connect_sync: None = ...
    cal_client_connect: typing.Callable[..., None] = ...
    cal_client_connect_finish: None = ...
    reserved: list[None] = ...

class ReminderWatcherPrivate(GObject.GPointer): ...

class TimezoneCache(GObject.GInterface):
    """
    Interface ETimezoneCache

    Signals from GObject:
      notify (GParam)
    """
    def add_timezone(self, zone: ICalGLib.Timezone) -> None: ...
    def get_timezone(self, tzid: str) -> typing.Optional[ICalGLib.Timezone]: ...
    def list_timezones(self) -> list[ICalGLib.Timezone]: ...

class TimezoneCacheInterface(GObject.GPointer):
    """
    :Constructors:

    ::

        TimezoneCacheInterface()
    """

    parent_interface: GObject.TypeInterface = ...
    tzcache_add_timezone: typing.Callable[
        [TimezoneCache, ICalGLib.Timezone], None
    ] = ...
    tzcache_get_timezone: None = ...
    tzcache_list_timezones: None = ...
    timezone_added: typing.Callable[[TimezoneCache, ICalGLib.Timezone], None] = ...
    reserved_signals: list[None] = ...

class ClientViewFlags(GObject.GFlags):
    NONE = 0
    NOTIFY_INITIAL = 1

class ObjModType(GObject.GFlags):
    ALL = 7
    ONLY_THIS = 8
    THIS = 1
    THIS_AND_FUTURE = 4
    THIS_AND_PRIOR = 2

class OperationFlags(GObject.GFlags):
    CONFLICT_FAIL = 1
    CONFLICT_KEEP_LOCAL = 0
    CONFLICT_KEEP_SERVER = 4
    CONFLICT_USE_NEWER = 2
    CONFLICT_WRITE_COPY = 8
    DISABLE_ITIP_MESSAGE = 16
    NONE = 0

class RecurDescribeRecurrenceFlags(GObject.GFlags):
    FALLBACK = 2
    NONE = 0
    PREFIXED = 1

class ReminderWatcherDescribeFlags(GObject.GFlags):
    MARKUP = 2
    NONE = 0

class ClientError(GObject.GEnum):
    INVALID_OBJECT = 2
    INVALID_RANGE = 5
    NO_SUCH_CALENDAR = 0
    OBJECT_ID_ALREADY_EXISTS = 4
    OBJECT_NOT_FOUND = 1
    UNKNOWN_USER = 3

class ClientSourceType(GObject.GEnum):
    EVENTS = 0
    MEMOS = 2
    TASKS = 1

class ComponentAlarmAction(GObject.GEnum):
    AUDIO = 1
    DISPLAY = 2
    EMAIL = 3
    NONE = 0
    PROCEDURE = 4
    UNKNOWN = 5

class ComponentAlarmTriggerKind(GObject.GEnum):
    ABSOLUTE = 3
    NONE = 0
    RELATIVE_END = 2
    RELATIVE_START = 1

class ComponentClassification(GObject.GEnum):
    CONFIDENTIAL = 3
    NONE = 0
    PRIVATE = 2
    PUBLIC = 1
    UNKNOWN = 4

class ComponentPeriodKind(GObject.GEnum):
    DATETIME = 0
    DURATION = 1

class ComponentRangeKind(GObject.GEnum):
    SINGLE = 0
    THISFUTURE = 2
    THISPRIOR = 1

class ComponentTransparency(GObject.GEnum):
    NONE = 0
    OPAQUE = 2
    TRANSPARENT = 1
    UNKNOWN = 3

class ComponentVType(GObject.GEnum):
    EVENT = 1
    FREEBUSY = 4
    JOURNAL = 3
    NO_TYPE = 0
    TIMEZONE = 5
    TODO = 2

class IntervalUnits(GObject.GEnum):
    DAYS = 2
    HOURS = 1
    MINUTES = 0
    NONE = -1
